# 캐시

### 브라우저 캐시
- 서버에 요청을 보내고 응답 데이터를 ***브라우저 캐시*** 라는 곳에 저장한다. 그러면 다음에 다시 요청할때 브라우저 캐시안에 데이터가 존재하면 
그 데이터를 바로 사용하고, 만약 데이터가 존재하지 않는다면 서버로 요청을 보낼 것이다.
- 하지만 브라우저 캐시에 데이터가 존재하면 추후에 서버에서 데이터가 변경되어도 요청자체를 보내지 않으니 변경된 데이터를 응답으로 받을 수 가 없다.

### 만료시간(mag-age)
- 브라우저 캐시의 ***만료시간***을 설정해주면 위와 같은 문제는 발생하지 않는다. cache-control 이라는 헤더에 max-age 을 설정해주면 브라우저 캐시의 만료시간이 설정될 것이다.
- 하지만 여기서도 문제가 있다. 브라우저 캐시 시간이 만료되면 서버로 요청을 보낼텐데, 데이터의 변경 유무와 상관없이 데이터를 무조건 응답으로 가져올 것이다. 
이말인 즉슨 서버 데이터가 변경되지 않았는데도 만료시간이 지나버려서 전과 동일한 데이터를 가져온다는 것자체가 불필요한 데이터 송수신이 이루어진다는 것이다.

### E-tag
- 위의 문제는 ***E-tag*** 설정으로 해결할 수 있다. E-tag는 데이터의 고유 해시값이다.
- 처음에 서버로 요청을 보내고 클라이언트로 데이터를 응답받을 때 E-tag값도 같이 응답받는다. 그리고 캐시 만료시간이 지나 서버로 재요청을 할때 E-tag 값도 같이 서버로 보낸다.
이를 통해 넘어온 E-tag값과 서버에서 생성된 E-tag값을 비교할 수 있고, 값이 같다면 동일한 데이터라는 의미로 데이터 전송을 하지않고 값이 다르다면 다른 데이터이기 때문에 
클라이언트로 데이터 응답을 수행 할 것이다.
- 하지만 결국 이 방법도 맹점이 존재한다. 왜냐하면 결국엔 캐시 만료시간이 다 되어야지만 서로의 E-tag값을 확인 할 수 있는데, 만약에 데이터가 바뀌어야하는 상황에 캐시 만료시간이 
엄청 길게 설정되어있다면 그 때까지 변경된 데이터는 응답을 받을 수 가 없기떄문이다.

### 파일의 이름
- 위 문제는 ***파일 이름에 버전이나 날짜정보***를 기입해서 업데이트하면 해결 가능하다. 기본적으로 브라우저는 파일의 이름이 변경되면 데이터가 변경되었다고 판단해서 서버로 요청을 전송하기 때문이다.


[출처] https://www.youtube.com/watch?v=NxFJ-mJdVNQ&t=604s
