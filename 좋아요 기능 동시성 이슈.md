# <작성중...>

# 개요
```
A라는 책에 100명의 사용자들이 좋아요 버튼을 클릭하면 좋아요 소는 100개가 된다.
근데 만약 동시에 100명이 좋아요 버튼을 누른다면 좋아요 갯수는 100개가 될까? 동시성 이슈때문에 내가 예상한 좋아요 갯수와는 다른 결과가 나온다. 예전에 강의에서 들었던 내용을 복기하고 해당 동시성 이슈에 대한 원인과 해결책을 정리해보려고 한다.  
```

# 상황
- 다음은 책에 좋아요를 표시하는 로직이다. 책을 db에서 불러와서 좋아요 카운팅이 +1 이된다.
```
    public BookResponseDto likeBook(final Long bookId) {
        final Book findBook = bookFindQueryService.findByIdWithPessimisticLock(bookId);

        findBook.addLike();

        return BookResponseDto.of(findBook);
    }
```

- 다음은 100개의 스레드를 생성 후 멀티스레드로 로직을 수행하는 테스트 코드다. 100번의 좋아요 로직을 실행시켰음으로 좋아요 갯수는 100이 되어야한다. 
```
    @Test
    public void likeConcurrencyTest() throws InterruptedException {
        int threadCount = 100;
        ExecutorService executorService = Executors.newFixedThreadPool(20);
        CountDownLatch latch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; ++i) {
            executorService.submit(() -> {
                try {
                    bookUpdateService.likeBook(1L);
                } finally {
                    latch.countDown();
                }
            });
        }
        latch.await();

        executorService.shutdown();

        Book book = bookRepository.findById(1L).orElseThrow();

        Assertions.assertThat(book.getLikes()).isEqualTo(100);
    }
```

# 문제 발생
- 다음과 같이 좋아요 갯수가 100개가 아닌 이상한 값이 나온다.
![4353](https://user-images.githubusercontent.com/22884224/223366888-ce6ec5a9-b3d9-4be4-a4a2-7dec8d106386.png)

# 원인 
- 위와 같이 나온 이유는 ***Rece Condition***이라는 문제 때문이다.
- Race condition은 둘 이상의 스레드가 공유 자원에 접근(=경쟁)해서 결과가 달라지는 문제를 의미한다. 해당 로직에서 공유자원은 좋아요 카운트이다
- Race Condition이 일어나는 상황의 예시는 다음 사진과 같다.
```
원하는 결과값은 두개의 스레드가 접근해서 좋아요를 눌렀기때문에 카운트는 2가 되야하지만, 
하나의 쓰레드1,2가 동시에 읽어서 같은 카운트 수를 가지고 있기때문에, 1을 더하는 로직을 수행해도 카운트는 2가 아닌 1이 된다.
```
![thread](https://user-images.githubusercontent.com/22884224/223390577-33899ed1-80b4-48c7-b8cc-1f190476add0.png)

